with Interfaces; use Interfaces;
with Interfaces.C; use Interfaces.C;
with Interfaces.C.Extensions;
with stdint;
with System;

with Allegro5.Altime;
with Allegro5.Base;
with Allegro5.Display;
with Allegro5.Joystick;
with Allegro5.Keyboard;
with Allegro5.Keycodes;
with Allegro5.Mouse;
with Allegro5.Timer;

package Allegro5.Events is

   -- TODO: private?
   type ALLEGRO_USER_EVENT_DESCRIPTOR is new System.Address;

   -- An event queue holds events that have been generated by event sources
   --that are registered with the queue. Events are stored in the order they
   --are generated. Access is in a strictly FIFO (first-in-first-out) order.
   type ALLEGRO_EVENT_QUEUE is new System.Address;

   -- A macro which evaluates to true if the event type is not a builtin
   --event type, i.e. one of those described in ALLEGRO_EVENT_TYPE.
   function ALLEGRO_EVENT_TYPE_IS_USER (t : unsigned) return Extensions.bool;

   -- Make an event type identifier, which is a 32-bit integer.
   --Usually, but not necessarily, this will be made from four 8-bit character
   --codes, for example:

   --    #define MY_EVENT_TYPE   ALLEGRO_GET_EVENT_TYPE('M','I','N','E')

   -- IDs less than 1024 are reserved for Allegro or its addons. Don't use
   --anything lower than ALLEGRO_GET_EVENT_TYPE(0, 0, 4, 0).

   -- You should try to make your IDs unique so they don't clash with
   --any 3rd party code you may be using. Be creative.
   --Numbering from 1024 is not creative.
   function ALLEGRO_GET_EVENT_TYPE(a : int; b : int; c : int; d : int) return int renames Allegro5.Base.AL_ID;

   subtype ALLEGRO_EVENT_TYPE is unsigned;
   ALLEGRO_EVENT_JOYSTICK_AXIS : constant ALLEGRO_EVENT_TYPE := 1;
   ALLEGRO_EVENT_JOYSTICK_BUTTON_DOWN : constant ALLEGRO_EVENT_TYPE := 2;
   ALLEGRO_EVENT_JOYSTICK_BUTTON_UP : constant ALLEGRO_EVENT_TYPE := 3;
   ALLEGRO_EVENT_JOYSTICK_CONFIGURATION : constant ALLEGRO_EVENT_TYPE := 4;
   ALLEGRO_EVENT_KEY_DOWN : constant ALLEGRO_EVENT_TYPE := 10;
   ALLEGRO_EVENT_KEY_CHAR : constant ALLEGRO_EVENT_TYPE := 11;
   ALLEGRO_EVENT_KEY_UP : constant ALLEGRO_EVENT_TYPE := 12;
   ALLEGRO_EVENT_MOUSE_AXES : constant ALLEGRO_EVENT_TYPE := 20;
   ALLEGRO_EVENT_MOUSE_BUTTON_DOWN : constant ALLEGRO_EVENT_TYPE := 21;
   ALLEGRO_EVENT_MOUSE_BUTTON_UP : constant ALLEGRO_EVENT_TYPE := 22;
   ALLEGRO_EVENT_MOUSE_ENTER_DISPLAY : constant ALLEGRO_EVENT_TYPE := 23;
   ALLEGRO_EVENT_MOUSE_LEAVE_DISPLAY : constant ALLEGRO_EVENT_TYPE := 24;
   ALLEGRO_EVENT_MOUSE_WARPED : constant ALLEGRO_EVENT_TYPE := 25;
   ALLEGRO_EVENT_TIMER : constant ALLEGRO_EVENT_TYPE := 30;
   ALLEGRO_EVENT_DISPLAY_EXPOSE : constant ALLEGRO_EVENT_TYPE := 40;
   ALLEGRO_EVENT_DISPLAY_RESIZE : constant ALLEGRO_EVENT_TYPE := 41;
   ALLEGRO_EVENT_DISPLAY_CLOSE : constant ALLEGRO_EVENT_TYPE := 42;
   ALLEGRO_EVENT_DISPLAY_LOST : constant ALLEGRO_EVENT_TYPE := 43;
   ALLEGRO_EVENT_DISPLAY_FOUND : constant ALLEGRO_EVENT_TYPE := 44;
   ALLEGRO_EVENT_DISPLAY_SWITCH_IN : constant ALLEGRO_EVENT_TYPE := 45;
   ALLEGRO_EVENT_DISPLAY_SWITCH_OUT : constant ALLEGRO_EVENT_TYPE := 46;
   ALLEGRO_EVENT_DISPLAY_ORIENTATION : constant ALLEGRO_EVENT_TYPE := 47;

   type ALLEGRO_EVENT_SOURCE_uu_pad_array is array (0 .. 31) of aliased int;

   -- An event source is any object which can generate events.
   --For example, an ALLEGRO_DISPLAY can generate events, and you can
   --get the ALLEGRO_EVENT_SOURCE pointer from an ALLEGRO_DISPLAY with
   --al_get_display_event_source.

   -- You may create your own "user" event sources that emit custom events.
   type ALLEGRO_EVENT_SOURCE is record
      uu_pad : aliased ALLEGRO_EVENT_SOURCE_uu_pad_array;
   end record;
   pragma Convention (C_Pass_By_Copy, ALLEGRO_EVENT_SOURCE);

   -- TODO: remove this?
   type ALLEGRO_ANY_EVENT is record
      c_type : aliased ALLEGRO_EVENT_TYPE;
      source : access ALLEGRO_EVENT_SOURCE;
      timestamp : aliased double;
   end record;
   pragma Convention (C_Pass_By_Copy, ALLEGRO_ANY_EVENT);

   -- TODO: move?
   type ALLEGRO_DISPLAY_EVENT is record
      c_type : aliased ALLEGRO_EVENT_TYPE;
      source : Display.ALLEGRO_DISPLAY;
      timestamp : aliased double;
      x : aliased int;
      y : aliased int;
      width : aliased int;
      height : aliased int;
      orientation : aliased int;
   end record;
   pragma Convention (C_Pass_By_Copy, ALLEGRO_DISPLAY_EVENT);

   -- TODO: move?
   type ALLEGRO_JOYSTICK_EVENT is record
      c_type : aliased ALLEGRO_EVENT_TYPE;
      source : Joystick.ALLEGRO_JOYSTICK;
      timestamp : aliased double;
      id : Joystick.ALLEGRO_JOYSTICK;
      stick : aliased int;
      axis : aliased int;
      pos : aliased float;
      button : aliased int;
   end record;
   pragma Convention (C_Pass_By_Copy, ALLEGRO_JOYSTICK_EVENT);

   -- TODO: move?
   type ALLEGRO_KEYBOARD_EVENT is record
      c_type : aliased ALLEGRO_EVENT_TYPE;
      source : Keyboard.ALLEGRO_KEYBOARD;
      timestamp : aliased double;
      display : Allegro5.Display.ALLEGRO_DISPLAY;
      keycode : aliased Keycodes.ALLEGRO_KEYCODE;
      unichar : aliased int;
      modifiers : aliased Keycodes.ALLEGRO_KEYMOD;
      repeat : aliased Extensions.bool;
   end record;
   pragma Convention (C_Pass_By_Copy, ALLEGRO_KEYBOARD_EVENT);

   -- TODO: move?
   type ALLEGRO_MOUSE_EVENT is record
      c_type : aliased ALLEGRO_EVENT_TYPE;
      source : Mouse.ALLEGRO_MOUSE;
      timestamp : aliased double;
      display : Allegro5.Display.ALLEGRO_DISPLAY;
      x : aliased int;
      y : aliased int;
      z : aliased int;
      w : aliased int;
      dx : aliased int;
      dy : aliased int;
      dz : aliased int;
      dw : aliased int;
      button : aliased unsigned;
      pressure : aliased float;
   end record;
   pragma Convention (C_Pass_By_Copy, ALLEGRO_MOUSE_EVENT);

   -- TODO: move?
   type ALLEGRO_TIMER_EVENT is record
      c_type : aliased ALLEGRO_EVENT_TYPE;
      source : Timer.ALLEGRO_TIMER;
      timestamp : aliased double;
      count : aliased Integer_64;
      error : aliased double;
   end record;
   pragma Convention (C_Pass_By_Copy, ALLEGRO_TIMER_EVENT);

   -- TODO: move?
   type ALLEGRO_USER_EVENT is record
      c_type : aliased ALLEGRO_EVENT_TYPE;
      source : access ALLEGRO_EVENT_SOURCE;
      timestamp : aliased double;
      uu_internal_u_descr : ALLEGRO_USER_EVENT_DESCRIPTOR;
      data1 : aliased stdint.intptr_t;
      data2 : aliased stdint.intptr_t;
      data3 : aliased stdint.intptr_t;
      data4 : aliased stdint.intptr_t;
   end record;
   pragma Convention (C_Pass_By_Copy, ALLEGRO_USER_EVENT);

   -- An ALLEGRO_EVENT is a union of all builtin event structures,
   --i.e. it is an object large enough to hold the data of any event type.
   --All events have the following fields in common:

   -- * type (ALLEGRO_EVENT_TYPE): Indicates the type of event.
   -- * any.source (ALLEGRO_EVENT_SOURCE *): The event source which
   --generated the event.
   -- * any.timestamp (double): When the event was generated.

   -- By examining the type field you can then access type-specific fields.
   --The any.source field tells you which event source generated
   --that particular event. The any.timestamp field tells you when
   --the event was generated. The time is referenced to the same starting
   --point as al_get_time.

   -- Each event is of one of the following types, with the usable fields given.
   type ALLEGRO_EVENT (discr : unsigned := 0) is record
      case discr is
         when 0 =>
            c_type : aliased ALLEGRO_EVENT_TYPE;
         when 1 =>
            any : aliased ALLEGRO_ANY_EVENT;
         when 2 =>
            display : aliased ALLEGRO_DISPLAY_EVENT;
         when 3 =>
            joystick : aliased ALLEGRO_JOYSTICK_EVENT;
         when 4 =>
            keyboard : aliased ALLEGRO_KEYBOARD_EVENT;
         when 5 =>
            mouse : aliased ALLEGRO_MOUSE_EVENT;
         when 6 =>
            timer : aliased ALLEGRO_TIMER_EVENT;
         when others =>
            user : aliased ALLEGRO_USER_EVENT;
      end case;
   end record;
   pragma Convention (C_Pass_By_Copy, ALLEGRO_EVENT);
   pragma Unchecked_Union (ALLEGRO_EVENT);

   -- Initialise an event source for emitting user events.
   --The space for the event source must already have been allocated.

   -- The user event source will never be destroyed automatically.
   --You must destroy it manually with al_destroy_user_event_source.
   procedure al_init_user_event_source (arg1 : access ALLEGRO_EVENT_SOURCE);
   pragma Import (C, al_init_user_event_source, "al_init_user_event_source");

   -- Destroy an event source initialised with al_init_user_event_source.

   -- This does not free the memory, as that was user allocated to begin with.
   procedure al_destroy_user_event_source (arg1 : access ALLEGRO_EVENT_SOURCE);
   pragma Import (C, al_destroy_user_event_source, "al_destroy_user_event_source");

   -- Emit a user event. The event source must have been initialised
   --with al_init_user_event_source. Returns false if the event source
   --isn't registered with any queues, hence the event wouldn't have been
   --delivered into any queues.

   -- Events are copied in and out of event queues, so after this function
   --returns the memory pointed to by event may be freed or reused.
   --Some fields of the event being passed in may be modified by the function.

   -- Reference counting will be performed if dtor is not NULL.
   --Whenever a copy of the event is made, the reference count increases.
   --You need to call al_unref_user_event to decrease the reference count
   --once you are done with a user event that you have received
   --from al_get_next_event, al_peek_next_event, al_wait_for_event, etc.

   -- Once the reference count drops to zero dtor will be called with
   --a copy of the event as an argument. It should free the
   --resources associated with the event, but not the event
   --itself (since it is just a copy).

   -- If dtor is NULL then reference counting will not be performed.
   --It is safe, but unnecessary, to call al_unref_user_event on
   --non-reference counted user events.
   function al_emit_user_event
     (arg1 : access ALLEGRO_EVENT_SOURCE;
      arg2 : access ALLEGRO_EVENT;
      dtor : access procedure (arg1 : access ALLEGRO_USER_EVENT)) return Extensions.bool;
   pragma Import (C, al_emit_user_event, "al_emit_user_event");

   -- Decrease the reference count of a user-defined event. This must be
   --called on any user event that you get from al_get_next_event,
   --al_peek_next_event, al_wait_for_event, etc. which is reference counted.
   --This function does nothing if the event is not reference counted.
   procedure al_unref_user_event (arg1 : access ALLEGRO_USER_EVENT);
   pragma Import (C, al_unref_user_event, "al_unref_user_event");

   -- Assign the abstract user data to the event source. Allegro does not use
   --the data internally for anything; it is simply meant as a convenient way
   --to associate your own data or objects with events.
   procedure al_set_event_source_data (arg1 : access ALLEGRO_EVENT_SOURCE; data : stdint.intptr_t);
   pragma Import (C, al_set_event_source_data, "al_set_event_source_data");

   -- Returns the abstract user data associated with the event source.
   --If no data was previously set, returns NULL.
   function al_get_event_source_data (arg1 : ALLEGRO_EVENT_SOURCE) return stdint.intptr_t;
   pragma Import (C, al_get_event_source_data, "al_get_event_source_data");

   -- Create a new, empty event queue, returning a pointer to object
   --if successful. Returns NULL on error.
   function al_create_event_queue return ALLEGRO_EVENT_QUEUE;
   pragma Import (C, al_create_event_queue, "al_create_event_queue");

   -- Destroy the event queue specified. All event sources currently
   --registered with the queue will be automatically unregistered before
   --the queue is destroyed.
   procedure al_destroy_event_queue (queue : ALLEGRO_EVENT_QUEUE);
   pragma Import (C, al_destroy_event_queue, "al_destroy_event_queue");

   -- Register the event source with the event queue specified. An event
   --source may be registered with any number of event queues simultaneously,
   --or none. Trying to register an event source with the same event queue more
   --than once does nothing.
   procedure al_register_event_source (queue : ALLEGRO_EVENT_QUEUE; arg2 : access ALLEGRO_EVENT_SOURCE);
   pragma Import (C, al_register_event_source, "al_register_event_source");

   -- Unregister an event source with an event queue. If the event source is
   --not actually registered with the event queue, nothing happens.

   --If the queue had any events in it which originated from the event source,
   --they will no longer be in the queue after this call.
   procedure al_unregister_event_source (queue : ALLEGRO_EVENT_QUEUE; arg2 : access ALLEGRO_EVENT_SOURCE);
   pragma Import (C, al_unregister_event_source, "al_unregister_event_source");

   -- Return true if the event queue specified is currently empty.
   function al_is_event_queue_empty (queue : ALLEGRO_EVENT_QUEUE) return Extensions.bool;
   pragma Import (C, al_is_event_queue_empty, "al_is_event_queue_empty");

   -- Take the next event out of the event queue specified, and copy the
   --contents into ret_event, returning true. The original event will be
   --removed from the queue. If the event queue is empty, return false and
   --the contents of ret_event are unspecified.
   function al_get_next_event (queue : ALLEGRO_EVENT_QUEUE; ret_event : access ALLEGRO_EVENT) return Extensions.bool;
   pragma Import (C, al_get_next_event, "al_get_next_event");

   -- Copy the contents of the next event in the event queue specified into
   --ret_event and return true. The original event packet will remain at the
   --head of the queue. If the event queue is actually empty, this function
   --returns false and the contents of ret_event are unspecified.
   function al_peek_next_event (queue : ALLEGRO_EVENT_QUEUE; ret_event : access ALLEGRO_EVENT) return Extensions.bool;
   pragma Import (C, al_peek_next_event, "al_peek_next_event");

   -- Drop (remove) the next event from the queue. If the queue is empty,
   --nothing happens. Returns true if an event was dropped.
   function al_drop_next_event (queue : ALLEGRO_EVENT_QUEUE) return Extensions.bool;
   pragma Import (C, al_drop_next_event, "al_drop_next_event");

   -- Drops all events, if any, from the queue.
   procedure al_flush_event_queue (queue : ALLEGRO_EVENT_QUEUE);
   pragma Import (C, al_flush_event_queue, "al_flush_event_queue");

   -- Wait until the event queue specified is non-empty. If ret_event is
   --not NULL, the first event in the queue will be copied into ret_event
   --and removed from the queue. If ret_event is NULL the first event is
   --left at the head of the queue.
   procedure al_wait_for_event (queue : ALLEGRO_EVENT_QUEUE; ret_event : access ALLEGRO_EVENT);
   pragma Import (C, al_wait_for_event, "al_wait_for_event");

   -- Wait until the event queue specified is non-empty. If ret_event is
   --not NULL, the first event in the queue will be copied into ret_event and
   --removed from the queue. If ret_event is NULL the first event is left at
   --the head of the queue.

   -- timeout_msecs determines approximately how many seconds to wait. If the
   --call times out, false is returned. Otherwise true is returned.
   function al_wait_for_event_timed
     (queue : ALLEGRO_EVENT_QUEUE;
      ret_event : access ALLEGRO_EVENT;
      secs : float) return Extensions.bool;
   pragma Import (C, al_wait_for_event_timed, "al_wait_for_event_timed");

   -- Wait until the event queue specified is non-empty. If ret_event is
   --not NULL, the first event in the queue will be copied into ret_event and
   --removed from the queue. If ret_event is NULL the first event is left at
   --the head of the queue.

   -- timeout determines how long to wait. If the call times out,
   --false is returned. Otherwise true is returned.
   function al_wait_for_event_until
     (queue : ALLEGRO_EVENT_QUEUE;
      ret_event : access ALLEGRO_EVENT;
      timeout : access Allegro5.Altime.ALLEGRO_TIMEOUT) return Extensions.bool;
   pragma Import (C, al_wait_for_event_until, "al_wait_for_event_until");

end Allegro5.Events;
